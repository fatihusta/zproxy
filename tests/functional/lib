#!/bin/bash

DIR="."
source "$DIR/variables"

error () {
	echo "ERROR: $1"
	exit 1
}

# if [[ "$NUM" == "" ]]; then error_param "backend_number"; fi
error_param () {
	error "the function '${FUNCNAME[1]}' expects the parameter '$1'"
}

msg () {
	echo ""
	echo "# $1"
}

start_debug () {
	rm -f $DEBUG_OUT
	tail -F $DEBUG_OUT 2>/dev/null &
}

stop_debug () {
	kill `ps aux |grep "tail -F $DEBUG_OUT" | grep -v grep | awk {'print$2'}` 2>/dev/null
}

debug () {
	if [[ $DEBUG -gt 0 ]]; then
		echo "debug> $1" >> $DEBUG_OUT
	fi
}

wait () {
	echo "Waiting for '$1' seconds..."
	sleep $1
}

cmd () {
	local CMD="$1"
	local OUT=$($CMD 2>&1)

	if [[ $? -ne 0 ]]; then
		echo "FAILED> CMD: $CMD"
		echo "FAILED> OUT: $OUT"
		echo ""
		return 1
	elif [[ $DEBUG -ge 2 ]]; then
		echo "debug> CMD: $CMD"
		if [[ $DEBUG -ge 3 ]]; then
			echo "OUT: $OUT"
		fi
		echo ""
	fi
	return 0
}

catch_cmd () {
	local CMD="$1"
	echo "cmd: $CMD"
	$CMD 2>&1
}

## proxy actions

# If it receives a configuration file, it will be loaded
start_proxy () {
	if [ "$1" != "" ]; then
		deploy_tpl "$1" $PROXY_CFG_F
	fi
	cmd "ip netns exec $PROXY_NS $PROXY_BIN -p $PROXY_PID_F -f $PROXY_CFG_F"
	wait $PROXY_GRACETIME
}

stop_proxy () {
	cmd "ip netns exec $PROXY_NS kill -9 `cat $PROXY_PID_F`"
}

stop_proxy_all () {
	cmd "pkill -9 zproxy"
}

restart_proxy () {
	stop_proxy
	start_proxy $1
}

apply_proxy_api () {
	local DATA=""
	if [[ -f ctl.json ]]; then
		DATA="-d @ctl.json"
	fi

	catch_cmd "ip netns exec $PROXY_NS $CURL_BIN -s --show-error --unix-socket $PROXY_CTL_SOCKET -X $METHOD $DATA http://${PROXY_SOCKET_IP}$URL" >ctl.out.tmp

	# Dump the CTL configuration and compare the saved one
	catch_cmd "ip netns exec $PROXY_NS $CURL_BIN -s --show-error --unix-socket $PROXY_CTL_SOCKET -X $PROXY_CTL_DUMP_METHOD http://${PROXY_SOCKET_IP}$PROXY_CTL_DUMP_URL" >>ctl.out.tmp

	OUT=$(diff ctl.out ctl.out.tmp)
	if [[ $? -eq 0 ]]; then
		rm ctl.out.tmp
	else
		msg "The CTL API changed"
		echo $OUT
		return 1
	fi

	return 0
}

# If it receives a configuration file, it will be loaded
reload_proxy () {
	if [ "$1" != "" ]; then
		deploy_tpl "$1" $PROXY_CFG_F
	fi

	clean_test
	URL="$PROXY_CTL_RELOAD_URL"
	METHOD="$PROXY_CTL_RELOAD_METHOD"
	apply_proxy_api
	ERR=$?

	wait $PROXY_GRACETIME
	return $ERR
}

## functions to manage the httpd backend server
start_httpd () {
	local ID="$1"
	local HTTP_CFG_F=$(get_bck_cfg_f $ID)
	local HTTP_PID=$(get_bck_pid_f $ID)

	HTTP_SITES_TPL="tpl/nginx-sites.conf"
	HTTP_SITE="/tmp/nginx-sites-$ID.conf"
	HTTP_WEBROOT="/tmp/http-app-$ID"

	deploy_tpl $HTTP_TPL $HTTP_CFG_F
	deploy_tpl $HTTP_SITES_TPL $HTTP_SITE
	mkdir $HTTP_WEBROOT
	echo "bck $ID" >$HTTP_WEBROOT/index.html
	echo "bck $ID, 404 Not Found" >$HTTP_WEBROOT/error_404.html

	cmd "ip netns exec $NS $HTTPD_BIN -c $HTTP_CFG_F"
}

stop_httpd () {
	local ID=$1
	if [[ "$ID" == "" ]]; then ID=1; fi

	local HTTP_CFG_F=$(get_bck_cfg_f $ID)
	local HTTP_PID_F=$(get_bck_pid_f $ID)
	local NS=$(get_bck_ns $ID)

	HTTP_SITE_F="/tmp/nginx-sites-$ID.conf"
	HTTP_WEBROOT="/tmp/http-app-$ID"

	cmd "ip netns exec $NS kill -15 `cat $HTTP_PID_F`"
	rm -rf $HTTP_CFG_F $HTTP_WEBROOT $HTTP_SITE_F
}

create_proxy () {

	cmd "ip netns add $PROXY_NS"

	cmd "ip link add $PROXY_IF netns $PROXY_NS type dummy"
	cmd "ip -net $PROXY_NS addr add $PROXY_VIP/16 dev $PROXY_IF"
	cmd "ip -net $PROXY_NS link set up dev $PROXY_IF"
}

delete_proxy () {
	cmd "ip netns del $PROXY_NS"
}

create_client () {

	local ID="$1"
	if [[ "$ID" == "" ]]; then ID=1; fi

	local NS=$(get_cl_ns $ID)
	local IF=$(get_cl_if $ID)
	local IP=$(get_cl_ip $ID)
	local GW=$(get_cl_gw $ID)

	cmd "ip netns add $NS"
	cmd "ip link add $IF netns $PROXY_NS type veth peer name $IF netns $NS"
	cmd "ip -net $NS addr add $IP/16 dev $IF"
	cmd "ip -net $NS link set up dev $IF"

	# add GW info
	cmd "ip -net $PROXY_NS addr add $GW/16 dev $IF"
	cmd "ip -net $PROXY_NS link set up dev $IF"
	cmd "ip -net $PROXY_NS route add to $IP dev $IF"
	cmd "ip -net $NS route add default via $GW"
}

add_clients () {
	local NUM="$1"
	if [[ "$NUM" == "" ]]; then error_param "client_number"; fi

	for ID in $(seq 1 $NUM); do
		create_client $ID
	done
}

delete_client () {
	local ID=$1
	if [[ "$ID" == "" ]]; then ID=1; fi
	local NS=$(get_cl_ns $ID)
	cmd "ip netns del $NS"
}

delete_clients () {
	local NUM="$1"
	if [[ "$NUM" == "" ]]; then error_param "client_number"; fi
	for ID in $(seq 1 $NUM); do
		delete_client $ID
	done
}

get_bck_pid_f () {
	local HTTP_PID_F="/tmp/http_bck$1.pid"
	echo "$HTTP_PID_F"
}

get_bck_cfg_f () {
	local HTTP_PID_F="/tmp/http_bck$1.conf"
	echo "$HTTP_PID_F"
}

# deploy_tpl $TPL_PATH $DST_PATH
deploy_tpl () {
	# expand the template variables with env ones
	TMP_ENV="/tmp/env.vars"

	TPL=$1
	DST=$2
	if [[ "$TPL" == "" ]]; then error_param "template_path"; fi
	if [[ "$DST" == "" ]]; then error_param "destination_path"; fi

	set >$TMP_ENV
	cp $TPL $DST
	for VAR in `grep -E '#{[a-zA-Z0-9_-]+}' $TPL | sed -E 's/^.*#\{//g' | sed -E 's/\}.*($|#\{)//g'`; do
		VAL=$(grep -E "^$VAR=" $TMP_ENV | sed -E 's/.*=//')
		if [ "$VAL" != "" ]; then
			sed -Ei "s,#\{$VAR\},$VAL,g" $DST
		else
			error "The '$VAR' variable for the '$TPL' template is not defined"
		fi
	done
}

create_backend () {

	local ID="$1"
	if [[ "$ID" == "" ]]; then ID=1; fi
	local NS=$(get_bck_ns $ID)
	local IF=$(get_bck_if $ID)
	local IP=$(get_bck_ip $ID)
	local ROUTER_IP=$(get_bck_gw $ID)

	cmd "ip netns add $NS"
	cmd "ip link add $IF netns $PROXY_NS type veth peer name $IF netns $NS"
	cmd "ip -net $NS addr add $IP/16 dev $IF"
	cmd "ip -net $NS link set up dev $IF"

	# add GW info
	cmd "ip -net $PROXY_NS addr add $ROUTER_IP/16 dev $IF"
	cmd "ip -net $PROXY_NS link set up dev $IF"
	cmd "ip -net $PROXY_NS route add to $IP dev $IF via $ROUTER_IP"
	cmd "ip -net $NS route add default via $ROUTER_IP"

	start_httpd $ID
}

add_backends () {

	for ID in $(seq 1 $1); do
		create_backend $ID
	done
}

delete_backend () {

	local ID=$1
	if [[ "$ID" == "" ]]; then ID=1; fi
	local NS=$(get_bck_ns $ID)

	stop_httpd $ID
	cmd "ip netns del $NS"
}

delete_backends () {
	local NUM="$1"
	if [[ "$NUM" == "" ]]; then error_param "backend_number"; fi

	for ID in $(seq $NUM); do
		delete_backend $ID
	done
}

get_test_out_f () {
	echo "test_$1_$2.out"
}

get_test_tmp_f () {
	echo "$1.tmp"
}

clean_test () {
	unset CMD CL METHOD SSL URL VHOST HEADERS BODY SSL REQUESTS RESOLV_VHOST
}

replace_test_out ()
{
	for F in  `find $DIR/tests/ -name *.out.tmp`
	do
		BASE=$(echo $F | sed -E "s/.tmp$//")
		echo "Renaming $BASE"
		mv $F ${BASE}
	done
}

## CLIENT ACTIONS
exec_request () {
	if [[ "$CL" == "" ]]; then error_param "client_id"; fi
	if [[ "$URL" == "" ]]; then error_param "url"; fi
	if [[ "$METHOD" == "" ]]; then error_param "method"; fi

	local CLNS=$(get_cl_ns $CL)
	HTTP="http"
	if [[ $SSL -eq 1 ]]; then
		HTTP="https"
	fi
	if [[ "$VHOST" = "" ]]; then
		VHOST="$PROXY_VIP:${PROXY_VPORT}"
	else
		RESOLV_VHOST="--resolve $VHOST:$PROXY_VPORT:$PROXY_VIP"
	fi
	catch_cmd "ip netns exec $CLNS $CURL_BIN --connect-timeout $CLIENT_CONN_TIMEOUT -s -k --show-error $RESOLV_VHOST $HTTP://${VHOST}$URL"
}

exec_average () {
	if [[ "$CL" == "" ]]; then error_param "client_id"; fi
	if [[ "$REQUESTS" == "" ]]; then error_param "iterations"; fi

	TMP="/tmp/avg"
	for IT in $(seq 1 $REQUESTS)
	do
		exec_request >> $TMP
	done

	cat $TMP | grep -E '.' |  sort | uniq -c
	rm $TMP
}

# exec_stress $CL $CONNS $TIMEOUT $THREADS
exec_benchmark() {
	if [[ "$CL" == "" ]]; then error_param "client_id"; fi
	if [[ "$URL" == "" ]]; then error_param "url"; fi
	if [[ "$METHOD" == "" ]]; then error_param "method"; fi

	local NS=$NS
	if [[ "$NS" == "" ]]; then NS=$(get_cl_ns $CL); fi
	local CONNS=$BENCH_CONNS
	local TIMEOUT=$BENCH_DELAY
	local THREADS=$BENCH_CL_THREADS

	local TMP="/tmp/bm"

	HTTP="http"
	if [[ $SSL -eq 1 ]]; then
		HTTP="https"
	fi
	if [[ "$VHOST" = "" ]]; then
		VHOST="$PROXY_VIP:${PROXY_VPORT}"
	fi

	catch_cmd "ip netns exec $NS $WRK_BIN -c $CONNS -d $TIMEOUT -t $THREADS $HTTP://${VHOST}$URL" >$TMP
	grep 'Requests/sec:' $TMP | sed -E 's/Requests\/sec:\s*//'
}

check_dependencies () {
	if [ $UID -ne 0 ]; then
		error "You must be root to run this test script"
	elif [[ ! -f "$CURL_BIN" ]]; then
		error "The 'curl' binary was not found, try to configure the variable 'CURL_BIN'"
	elif [[ ! -f "$WRK_BIN" ]]; then
		error "The 'wrk' binary was not found, try to configure the variable 'WRK_BIN'"
	elif [[ ! -f "$HTTPD_BIN" ]]; then
		error "The 'ngnix' binary was not found, try to configure the variable 'HTTPD_BIN'"
	elif [[ ! -f "$PROXY_BIN" ]]; then
		error "The 'zproxy' binary was not found, try to configure the variable 'PROXY_BIN'"
	elif [[ ! -f "$PROXY_BIN" ]]; then
		error "The 'zproxyctl' binary was not found, try to configure the variable 'PROXY_BIN'"
	fi

	#~ add hosts to /etc/hosts
}

print_report () {
	if [[ "$1" == "" ]]; then error_param "test_name"; fi
	if [[ "$2" == "" ]]; then error_param "command_name"; fi
	if [[ "$3" == "" ]]; then error_param "output_file"; fi

	# print stdout
	echo "# Error in test $1, cmd $2"
	cat $3
	echo "##############################"

	# print file
	echo "# Error in test $1, cmd $2" >>$REPORT_F
	cat $3 >>$REPORT_F
	echo "" >>$REPORT_F
	echo "##############################" >>$REPORT_F
}

